\input texinfo      @c -*-texinfo-*-
@setfilename ruby-debug.info

@set DBG ruby-debug
@set ttrdebug @code{rdebug}
@set ttDBG @code{@value{DBG}}
@set Emacs @sc{gnu} Emacs

@set RDEBUG_VERSION 0.9.4

@macro Example {}
@iftex
@cartouche
@end iftex
@smallexample
@end macro

@macro EndExample {}
@iftex
@end cartouche
@end iftex
@end smallexample
@end macro

@macro DBG {}
@value{DBG}
@end macro

@macro ttDBG {}
@value{ttrdebug}
@end macro

@c How to show optional variables.
@macro ovar{varname}
@r{[}@var{\varname\}@r{]}
@end macro

@settitle ruby-debug
@setchapternewpage odd
@c %**end of header

@include version.texi

@finalout

@c THIS MANUAL REQUIRES TEXINFO 4.0 OR LATER.

@c This is a dir.info fragment to support semi-automated addition of
@c manuals to an info tree.
@dircategory Programming & development tools.
@direntry
* ruby-debug: (ruby-debug).    Ruby Debugger
@end direntry

@titlepage
@title Debugging with @code{ruby-debug} Version @value{RDEBUG_VERSION}
@sp 1
@subtitle @value{EDITION} Edition
@subtitle @value{UPDATED-MONTH}
@c @author ...
@page
@ifset WHERETO
@tex
{\parskip=0pt
\hfill (Send bugs and comments on ruby-debug to fill in...)\par
\hfill {\it Debugging with {\tt ruby-debug}\par
\hfill \TeX{}info \texinfoversion\par
}
@end tex
@end ifset
@end titlepage
@page

@ifnottex
@node Top, Summary, (dir), (dir)
@top Debugging with ruby-debug

This file describes ruby-debug, the Ruby Debugger, 
version @value{RDEBUG_VERSION}

This is the @value{EDITION} Edition, @value{UPDATED}
@c Copyright (C) 2007 ...

@menu
* Summary::                     Overview of Debugger with sample sessions
* Invocation::                  Getting in and out
* Debugger Command Reference::  rdebug command reference
* Post-Mortem Debugging::       Debugging on an uncaught exception
* Debugger Module and Class::   ruby-debug's Debugger module and class
* GNU Emacs::                   Using @code{ruby-debug} from GNU Emacs

Indexes (nodes containing large menus)
* Command Index::             An item for each command name.
* General Index::             An item for each concept.
@end menu

@end ifnottex

@contents

@node Summary
@chapter Summary of @code{ruby-debug}

The purpose of a debugger such as @DBG is to allow you to see what is
going on ``inside'' a Ruby program while it executes.

@ttDBG{} can do four main kinds of things (plus other things in support of
these) to help you catch bugs in the act:

@itemize @bullet
@item
Start your script, specifying anything that might affect its behavior.

@item
Make your script stop on specified conditions.

@item
Examine what has happened, when your script has stopped.

@item
Change things in your script, so you can experiment with correcting the
effects of one bug and go on to learn about another.
@end itemize

Although you can use @value{ttrdebug} to invoke your Ruby programs via
a debugger at the outset, there are other ways to use and enter the
debugger. 

@menu
* First Sample Session::   A Simple Sample @code{rdebug} session
* Second Sample Session::  Second Session Delving a little deper @code{rdebug} session
* Unit Testing Session::   Using the debugger in unit testing
* Debugging Oddities::     How debugging Ruby may be different...
@end menu

@node First Sample Session
@section The First Sample @code{rdebug} Session (@code{list}, @code{display}, @code{print}, and @code{quit})

You can use this manual at your leisure to read all about @value{ttDBG}.
However, a handful of commands are enough to get started using the
debugger.  The following sections illustrates these commands.

@iftex
In this sample session, we emphasize user input like this: @b{input},
to make it easier to pick out from the surrounding output.
@end iftex

Below is Ruby code to compute a triangle number of a given
length.@footnote{There are of course shorter ways to define @code{triangle}
such as:
@smallexample
def triangle(n) (0..n).inject@{|sum, i| sum +=i@} end
@end smallexample
or even:
@smallexample
  def triangle(n) (n * (n+1)) / 2 end
@end smallexample
The code we use in this example and the next is more for pedagogical
purposes than how to write short Ruby code. Stepping through the
@code{inject} version given above leads to some interesting behavior.}


@smallexample
$ @b{rdebug triangle.rb}
triangle.rb:4 def hanoi(n,a,b,c)
(rdb:1) @b{list}
[-1, 8] in ./triangle.rb
   1  #!/usr/bin/env ruby
   2  # Compute the n'th triangle number - the hard way
   3  # triangle(n) == (n * (n+1)) / 2
=> 4  def triangle(n)
   5    tri = 0
   6    0.upto(n) do |i|
   7      tri += i
   8    end
(rdb:1) @b{l}
[9, 18] in ./triangle.rb
   9    return tri
   10  end
   11  
   12  puts triangle(3)
(rdb:1) @b{list 1,100}
[1, 100] in ./triangle.rb
   1  #!/usr/bin/env ruby
   2  # Compute the n'th triangle number - the hard way
   3  # triangle(n) == (n * (n+1)) / 2
=> 4  def triangle(n)
   5    tri = 0
   6    0.upto(n) do |i|
   7      tri += i
   8    end
   9    return tri
   10  end
   11  
   12  puts triangle(3)
(rdb:1) 
@end smallexample

@noindent

There are lots of command options, but we don't need them for now. See
@ref{rdebug command-line options} for a full list of command options.

Position information consists of a filename and line number,
e.g. @code{triangle.rb:4}. We are currently stopped before the first
executable line of the program; this is line 4 of
@code{triangle.rb}. If you are used to less dynamic languages and have
used debuggers for more statically compiled languages like C, C++, or
Java, it may seem odd to be stopped before a function definition.  But
in Ruby line 4 is executed, the name @code{triangle} (probably) does
not exist so issuing a method call of @code{triangle} will raise a
``method not found'' error.

@DBG{}'s prompt is @code{(rdb:@emph{n})}. The @emph{n} is the thread
number. Here it is 1 which is usually the case for the main thread. If
the program has died and you are in post-mortem debugging, there is no
thread number. In this situation, the string @code{post-mortem} is
used in place of a thread number.

The first command, @code{list} (@pxref{List}), prints 10 lines
centered around the current line; the current line here is line 4 and
is marked by @code{=>}, so the range the debugger would like to show
is -1..8. However since there aren't 5 lines before the current line,
those additional lines---``lines'' -1 and 0---are dropped and we print
the remaining 8 lines.  The @code{list} command can be abbreviated
with @code{l} which is what we use next. Notice that when we use this
a second time, we continue listing from the place we last left
off. The desired range of lines this time is lines 9 to 18; but since
the program ends as line 12, only the remaining 4 lines are shown.

If you want to set how many lines to print by default rather than use
the initial number of lines, 10, use the @code{set listsize} command
(@pxref{Listsize}). To see the entire program in one shot, we gave an
explicit starting and ending line number.

If you use a front-end to the debugger such as the Emacs interface
(@pxref{GNU Emacs}), you probably won't use @code{list} all that much.

Now let us step through the program.

@smallexample
(rdb:1) @b{step}
triangle.rb:12
puts triangle(3)
(rdb:1) @b{@key{<RET>}}
triangle.rb:5
tri = 0
(rdb:1) @b{p tri}
nil
(rdb:1) step
triangle.rb:6
0.upto(n) do |i|
(rdb:1) p tri
0
@end smallexample

The first @kbd{step} command (@pxref{Step}) runs the script one
executable unit. The second command we entered was just hitting the
return key; @ttDBG{} remembers the last command you entered was
@code{step}, so it runs that last command again.

One way to print the values of variables uses @code{p}. (Of course,
there are of course lots of other ways too.). When we look at the
value of @code{tri} the first time, we see it is @code{nil}. Again we
are stopped @emph{before} the assignment on line 5, and this variable
hasn't been set previously. However after issuing another ``step''
command we see that the value is 0 as expected.

If we want to see the value of @code{tri} every time we stop to see
how this is going to change we can give a display expression
(@pxref{DisplayCommands}).

@smallexample
(rdb:1) display tri
1: tri = 0
@end smallexample

Now let us run the program until we return from the function. However
we'll want to see which lines get run.

@smallexample
(rdb:1) @b{display i}
2: i =
(rdb:1) @b{set linetrace on}
line tracing is on.
(rdb:1) @b{finish}
Tracing(1):triangle.rb:7 tri += i
1: tri = 0
2: i = 0
Tracing(1):triangle.rb:7 tri += i
1: tri = 0
2: i = 1
Tracing(1):triangle.rb:7 tri += i
1: tri = 1
2: i = 2
Tracing(1):triangle.rb:7 tri += i
1: tri = 3
2: i = 3
Tracing(1):triangle.rb:9 return tri
1: tri = 6
2: i =
(rdb:1) @b{quit}
Really quit? (y/n) y
@end smallexample

So far, so good. A you can see from the above to get out of the
debugger, one can issue a @code{quit} command.

@node Second Sample Session
@section Sample Session 2: Delving Deeper 

In this section we'll introduce breakpoints, the call stack and
restarting.  
So far we've been doing pretty good in that we've not encountered a bug
to fix. Let's try another simple example. Okay here's the program.

Below we will debug a simple Ruby program to solve the classic Towers
of Hanoi puzzle. It is augmented by the bane of programming: some
command-parameter processing with error checking.

@smallexample
$ @b{rdebug hanoi.rb}
hanoi.rb:3 def hanoi(n,a,b,c)
(rdb:1) @b{list 1,100}
[1, 100] in ./hanoi.rb
   1  #!/usr/bin/ruby
   2
=> 3  def hanoi(n,a,b,c)
   4      if n-1 > 0
   5         hanoi(n-1, a, c, b)
   6      end
   7      puts "Move disk %s to %s" % [a, b]
   8      if n-1 > 0
   9         hanoi(n-1, c, b, a)
   10      end
   11  end
   12
   13  i_args=ARGV.length
   14  if i_args > 1
   15      puts "*** Need number of disks or no parameter"
   16      exit 1
   17  end
   18
   19  n=3
   20
   21  if i_args > 0
   22      begin
   23        n = ARGV[0].to_i
   24      rescue ValueError, msg:
   25          print "** Expecting an integer, got: %s" % ARGV[0].to_s
   26        exit 2
   27      end
   28  end
   29
   30  if n < 1 or n > 100
   31      puts "*** number of disks should be between 1 and 100"
   32      exit 2
   33  end
   34
   35  hanoi(n, :a, :b, :c)
(rdb:1)
@end smallexample

Recall in the first section I said that before the @code{def} is run
the method it names is undefined. Let's check that out. First let's
see what private methods we can call before running @code{def hanoi}

@smallexample
(rdb:1) @b{set autoeval on}
autoeval is on.
(rdb:1) @b{private_methods}
["select", "URI", "local_variables", "lambda", "chomp", ... 
@end smallexample

The @code{set autoeval} (@pxref{Autoeval}) command causes any commands
that are not normally understood to be debugger commands to get
evaluated as though they were Ruby commands. I use this a lot, so I
set this by putting it the command file @code{.rdebugrc},
@pxref{Command Files}, that gets read when @code{ruby-debug} starts.

As showing the list output of @code{private_methods}, I find this kind
of list unwieldy. What you are supposed to notice here is that
method @code{hanoi} is not in this list. When you ask
@code{ruby-debug} for a list of method names via @code{method
instance}, it doesn't show output in this way; @code{ruby-debug} can
sort and put into columns lists like this using the print command, @code{ps}.


@smallexample
(rdb:1) @b{ps private_methods}
Array                    exit!                 puts                        warn
Float                    fail                  raise                       y
Integer                  fork                  rand
Rational                 format                readline
String                   gem_original_require  readlines
URI                      getc                  remove_instance_variable
`                        gets                  scan
abort                    global_variables      select
active_gem_with_options  gsub                  set_trace_func
at_exit                  gsub!                 singleton_method_added
autoload                 initialize            singleton_method_removed
autoload?                initialize_copy       singleton_method_undefined
binding                  iterator?             sleep
block_given?             lambda                split
callcc                   load                  sprintf
caller                   local_variables       srand
catch                    location_of_caller    sub
chomp                    loop                  sub!
chomp!                   method_missing        syscall
chop                     open                  system
chop!                    p                     test
dbg_print                pp                    throw
dbg_puts                 print                 timeout
eval                     printf                trace_var
exec                     proc                  trap
exit                     putc                  untrace_var
@end smallexample

Now let's see what happens after stepping

@smallexample
(rdb:1) @b{private.methods.member?("hanoi")}
false
(rdb:1) @b{step}
hanoi.rb:13
i_args=ARGV.length
(rdb:1) @b{private_methods.member?("hanoi")}
true
(rdb:1)
@end smallexample

Okay, now where were we?

@smallexample
(rdb:1) @b{list}
[8, 17] in ./hanoi.rb
   8      if n-1 > 0
   9         hanoi(n-1, c, b, a)
   10      end
   11  end
   12
=> 13  i_args=ARGV.length
   14  if i_args > 1
   15      puts "*** Need number of disks or no parameter"
   16      exit 1
   17  end
(rdb:1) @b{ARGV}
[]
@end smallexample

Ooops. We forgot to specify any parameters to this program. Let's try
again. We can use the @code{restart} command here.

@smallexample
(rdb:1) @b{restart 3}
Re exec'ing:
        /usr/bin/rdebug hanoi.rb 3
hanoi.rb:3
def hanoi(n,a,b,c)
(rdb:1) @b{break 4}
Breakpoint 1 file hanoi.rb, line 4
(rdb:1) @b{continue}
Breakpoint 1 at hanoi.rb:4
./hanoi.rb:4 if n-1 > 0
(rdb:1) @b{display n}
1: n = 3
(rdb:1) @b{display a}
2: a = a
(rdb:1) @b{undisplay 2}
(rdb:1) @b{display a.inspect}
3: a.inspect = :a
(rdb:1) @b{display b.inspect}
4: b.inspect = :b
(rdb:1) @b{continue}
Breakpoint 1 at hanoi.rb:4
./hanoi.rb:4 
if n-1 > 0
1: n = 2
3: a.inspect = :a
4: b.inspect = :c
(rdb:1) @b{c}
Breakpoint 1 at hanoi.rb:4
./hanoi.rb:4 
if n-1 > 0
1: n = 1
3: a.inspect = :a
4: b.inspect = :b
(rdb:1) @b{where}
--> #0 Object.hanoi(n#Fixnum, a#Symbol, b#Symbol, c#Symbol) at line hanoi.rb:4
    #1 Object.-(n#Fixnum, a#Symbol, b#Symbol, c#Symbol) at line hanoi.rb:5
    #2 Object.-(n#Fixnum, a#Symbol, b#Symbol, c#Symbol) at line hanoi.rb:5
    #3 at line hanoi.rb:35
(rdb:1) 
@end smallexample

In the above we added a new command, @code{break}
(@pxref{Breakpoints}) which indicates to go into the debugger just
before that line of code is run. And @code{continue} resumes
execution.  Notice the difference between @code{display a} and
@code{display a.inspect}. An implied string conversion is performed on
the expression after it is evaluated. To remove a display expression
we used @code{undisplay} is used. If we give a display number, just
that display expression is removed.

Above we also used a new comand @code{where} (@pxref{Backtrace} to
show the call stack. In the above situation, starting from the bottom
line we se we called the hanoi from line 35 of the file
@code{hanoi.rb} and the hanoi method called itself two more times at
line 5.

In the call stack we show the file line position in the same format
when we stop at a line. Also we see the names of the parameters and
the types that those parameters @emph{currently} have. It's possible
that when the program was called the parameter had a different type,
since the types of variables can change dynamically. You alter the
style of what to show in the trace (@pxref{Callstyle}).

Let's explore a little more. Now were were we? 

@smallexample
(rdb:1) @b{list}
   1  #!/usr/bin/ruby
   2
   3  def hanoi(n,a,b,c)
=> 4      if n-1 > 0
   5         hanoi(n-1, a, c, b)
   6      end
   7      puts "Move disk %s to %s" % [a, b]
   8      if n-1 > 0
(rdb:1) @b{undisplay}
Clear all expressions? (y/n) @b{y}
(rdb:1) @b{i_args}
NameError Exception: undefined local variable or method `i_args' for main:Object
(rdb:1) @b{frame -1}
#3 at line hanoi.rb:35
(rdb:1) @b{i_args}
1
(rdb:1) @b{p n}
3
(rdb:1) @b{down 2}
#2 Object.-(n#Fixnum, a#Symbol, b#Symbol, c#Symbol) at line hanoi.rb:5
(rdb:1) @b{p n}
2
@end smallexample

Notice in the above to get the value of variable @code{n}, I have to
use a print command like @code{p n}; If I entered just @code{n}, that
would be taken to mean the debugger command ``next''. In the current
scope, variable @code{i_args} is not defined. However I can change to
the topmost frame by using the @code{frame} command. Just as with
arrays, -1 means the last one. Alternatively using frame number 3
would have been the same thing; so would issuing @code{up 3}.

Note that in the outside frame 3, the value of @code{i_args} can be
shown. Also note that the value of variable @code{n} is different.

@node Unit Testing Session
@section Using the debugger in unit testing

In the previous sessions we've been calling the debugger right at the
outset. I confess that this mode of operation is usually not how I use
the debugger.

There are a number of situations where calling the debugger at the outset is
impractical for a couple of reasons.

@enumerate
@item 
The debugger just doesn't work when run at the outset.  By necessity
any debugging changes to the behavior or the program in slight and
subtle ways, and sometimes this can hinder finding the bugs.
@item 
There's a lot of code which that needs to get run before the part you
want to inspect. Running this code takes time and you don't the
overhead of the debugger in this first part.
@end enumerate

In this section we'll delve show how to enter the code in the middle
of your program, while delving more into the debugger operation.

In this section we will also use unit testing. Using unit tests will
greatly reduce the amount of debugging needed while at the same time
increase the quality of your program.

What we'll do is take the @code{triangle} code from the first session
and write a unit test for that. In a sense we did write a mini-test
for the program which was basically the last line where we printed the
value of triangle(3). This test however wasn't automated: the
implication is that someone would look at the output and verify that
what was printed is what was expected.

And before we can turn that into something that can be
@code{required}, we probably want to remove that output. However I
like to keep in that line so that when I look at the file, I have an
example of how to run it.  Therefore we will conditionally run this
line if that file is invoked directly, but skip it if it is
not.@footnote{If you want to be able to run @code{rdebug} from the
outset on this code in ``standalone'' operation, the condition needs to
more complicated because @code{$0} will be @code{rdebug} rather than
the program, @code{tri2.rb} here. And if you use @code{rcov} to test
program coverage, it will show this code as being ``dead''. To get
around thse problems here's the actual condition test I use:
@smallexample
if __FILE__ == $0 or
    ($DEBUG and ['rdebug', 'rcov'].include?(File.basename($0)))
@end smallexample
The test for @code{$DEBUG} is so that if I am debugging some
@emph{other} piece of code and require this file, I don't run this
section. And this also means that I have to save and restore
@code{$DEBUG} before requiring this file. It's ugly, but it works.}
@smallexample
  if __FILE__ == $0 
    puts triangle(3)
  end
@end smallexample

Let's call this file @code{tri2.rb}.

Okay, we're now ready to write our unit test. We'll use
@code{"test/unit"} which comes with the standard Ruby distribution.
Here's the test code:

@smallexample
  #!/usr/bin/env ruby
  require "test/unit"
  require "tri2.rb"

  class TestTri < Test::Unit::TestCase
    def test_basic
     solutions = []
     0.upto(5) do |i|
        solutions << triangle(i)
      end
      assert_equal([0, 1, 3, 6, 10, 15], solutions,
                   "Testing the first 5 triangle numbers")
    end
  end
@end smallexample

If you run it will work. However if you run @code{rdebug} initially,
you wan't get into the test, because @code{test/unit} wants to be the
main program. So here is a situation where one needs to modify the
program to add an explicit call to the debugger.

One way to do this is to add the following before the place you want
to stop:
@smallexample
  require "rubygems"
  require "ruby-debug/debugger"
@end smallexample
The line @code{require "rubygems"} is needed if @code{ruby-debug} is
installed as a Ruby gem.

Let's add this code just after entering @code{test_basic}:
@smallexample
  ... 
  def test_basic
    @b{require "rubygems"}
    @b{require "ruby-debug/debugger"}
    solutions = []
   ...
@end smallexample

Now we run the program..
@smallexample
  $ @b{ruby test-tri.rb}
  Loaded suite test-tri
  Started
  test-tri.rb:9
  solutions = []
  (rdb:1)
@end smallexample
and we see that we are stopped at line 9 just before the
initialization of the list @code{solutions}.

Now let's see where we are...

@smallexample
(rdb:1) @b{where}
--> #0 TestTri.test_basic at line /home/rocky/ruby/test-tri.rb:9
(rdb:1) 
@end smallexample

Something seems wrong here; @code{TestTri.test_basic} indicates that
we are in class @code{TestTri} in method @code{test_basic}. However we
don't see the call to this like we did in the last example when we
used the @code{where} command. This is because the debugger really
didn't spring into existence until after we already entered that
method, and Ruby doesn't keep call stack information around in a
way that will give the information we show when running @code{where}.

If we want call stack information, we have to turn call-stack tracking
on @emph{beforehand}. This is done by adding @code{Debugger.start}.

Here's what our test program looks like so after we modify it to start
tracking calls from the outset

@smallexample
#!/usr/bin/env ruby
require "test/unit"
require "tri2.rb"
require "rubygems"
@b{require "ruby-debug"}
@b{Debugger.start}

class TestTri < Test::Unit::TestCase
  def test_basic
    @b{debugger}
    solutions = []
    0.upto(5) do |i|
      solutions << triangle(i)
    end
    assert_equal([0, 1, 3, 6, 10, 15], solutions,
                 "Testing the first 5 triangle numbers")
  end
end
@end smallexample

Now when we run this:
@smallexample
$ @b{ruby test-tri2.rb}
Loaded suite test-tri2
Started
test-tri2.rb:11
solutions = []
(rdb:1) @b{where}
--> #0 TestTri.test_basic at line test-tri2.rb:11
    #1 Kernel.__send__(result#Test::Unit::TestResult) 
       at line /usr/lib/ruby/1.8/test/unit/testcase.rb:70
    #2 Test::Unit::TestCase.run(result#Test::Unit::TestResult) 
       at line /usr/lib/ruby/1.8/test/unit/testcase.rb:70
...
    #11 Test::Unit::AutoRunner.run 
       at line /usr/lib/ruby/1.8/test/unit/autorunner.rb:200
    #12 Test::Unit::AutoRunner.run(force_standalone#FalseClass, default_dir#NilClass,...) 
       at line /usr/lib/ruby/1.8/test/unit/autorunner.rb:13
    #13 at line /usr/lib/ruby/1.8/test/unit.rb:285
(rdb:1) 
@end smallexample

Much better. But again let me emphasize that the parameter types are
those of the corresponding variables that @emph{currently} exist, and
this might have changed since the time when the call was made. Even so
and even though we only have @emph{types} listed, it's a pretty good
bet that when @code{Test::Unit} was first called, shown above as frame
12, that the values of its two parameters were @code{false} and
@code{nil}.

@node Debugging Oddities
@section How debugging Ruby may be different than debugging other Languages

If you are used to debugging in other langauges like C, C++, Perl,
Java or even Bash@footnote{this is just an excuse to put in a
shameless plug for my bash debugger @url{http://bashdb.sf.net}}, there
may be a number of things that seem or feel a little bit different and
may confuse you. A number of these things aren't oddities of the
debugger per se, so much as a difference in how Ruby works compared to
those other languages. Because Ruby works a little differently from
those other languages, writing a debugger has to also be a little
different as well if it is to be useful.

In this respect, using the debugger may help you understand Ruby
better.

We've already seen two examples of such differences. One difference is
the fact that we stop on method definitions or @code{def}'s and that's
because these are in fact executable statements. In other compiled
languages this would not happen because that's already been done when
you compile the program (or in Perl when it scans in the program). The
other difference we saw was in our inability to show call stack parameter
types without having made arrangements for the debugger to track
this. In other languages call stack information is usually available
without asking assistance of the debugger.@footnote{However in C, and
C++ generally you have to ask the compiler to add such information.}

In this section we'll consider some other things that might throw
off new users to Ruby who are familiar with other languages and
debugging in them.

@subsection Multiple Evaluations per line
Consider this simple program to compute the Greatest Common Divisor of
two numbers:
@smallexample
#!/usr/bin/env ruby

# GCD. We assume positive numbers
def gcd(a, b)
  # Make: a <= b
  if a > b
    a, b = [b, a]
  end

  return nil if a <= 0

  if a == 1 or b-a == 0
    return a
  end
  return gcd(b-a, a)
end

a, b = ARGV[0..1].map @{|arg| arg.to_i@}
puts "The GCD of %d and %d is %d" % [a, b, gcd(a, b)]
@end smallexample

Now let's try stepping through the program to see what we get.
@smallexample
$ rdebug gcd.rb 3 5
def gcd(a, b)
(rdb:1) @b{set linetrace on}
line tracing is on.
(rdb:1) @b{step 20}
Tracing(1):gcd.rb:18 a, b = ARGV[0..1].map @{|arg| arg.to_i@}
Tracing(1):gcd.rb:18 a, b = ARGV[0..1].map @{|arg| arg.to_i@}
Tracing(1):gcd.rb:18 a, b = ARGV[0..1].map @{|arg| arg.to_i@}
Tracing(1):gcd.rb:19 puts "The GCD of %d and %d is %d" % [a, b, gcd(a, b)]
Tracing(1):gcd.rb:6 if a > b
Tracing(1):gcd.rb:6 if a > b
Tracing(1):gcd.rb:10 return nil if a <= 0
Tracing(1):gcd.rb:10 return nil if a <= 0
Tracing(1):gcd.rb:12 if a == 1 or b-a == 0
Tracing(1):gcd.rb:12 if a == 1 or b-a == 0
Tracing(1):gcd.rb:15 return gcd(b-a, a)
Tracing(1):gcd.rb:6 if a > b
Tracing(1):gcd.rb:6 if a > b
Tracing(1):gcd.rb:10 return nil if a <= 0
Tracing(1):gcd.rb:10 return nil if a <= 0
Tracing(1):gcd.rb:12 if a == 1 or b-a == 0
Tracing(1):gcd.rb:12 if a == 1 or b-a == 0
Tracing(1):gcd.rb:15 return gcd(b-a, a)
Tracing(1):gcd.rb:6 if a > b
Tracing(1):gcd.rb:6 if a > b
gcd.rb:6
if a > b
(rdb:1) @b{where}
--> #0 Object.gcd(a#Fixnum, b#Fixnum) at line gcd.rb:6
    #1 Object.-(a#Fixnum, b#Fixnum) at line gcd.rb:15
    #2 Object.-(a#Fixnum, b#Fixnum) at line gcd.rb:15
    #3 at line gcd.rb:19
(rdb:1) 
@end smallexample

The thing to note here is that we see lots of lines duplicated. For
example, the first line:
@smallexample
Tracing(1):gcd.rb:18 a, b = ARGV[0..1].map @{|arg| arg.to_i@}
@end smallexample
appears three times. If we were to break this line into the equivalent
multi-line expression:
@smallexample
a, b = ARGV[0..1].map do |arg| 
  arg.to_i
end
@end smallexample
we would find one stop at the first line before running @code{map} and
two listings of @code{arg.to_i}, once for each value of arg which here
is 0 and then 1. 

But what about those @code{if} statements? Each one is listed twice
whether or not we put the @code{if} at the beginning or the end.

Each @code{if} statement appears twice because we stop once before the expression
is evaluated and once after the expression is evaluated but before the
if statement takes hold.

If you are issuing a @code{step} command one at a time, the repetitive
nature can be little cumbersome if not annoying. So @value{DBG} offers
a variant called @code{step+} which forces a new line on every
step. Let's try that.
@smallexample
(rdb:1) @b{R}
Re exec'ing:
	/usr/bin/rdebug gcd.rb 3 5
gcd.rb:4
def gcd(a, b)
(rdb:1) @b{step+}
gcd.rb:18
a, b = ARGV[0..1].map @{|arg| arg.to_i@}
(rdb:1) @b{step+}
gcd.rb:19
puts "The GCD of %d and %d is %d" % [a, b, gcd(a, b)]
(rdb:1) @b{step+}
gcd.rb:6
if a > b
(rdb:1) @b{step+}
gcd.rb:10
return nil if a <= 0
(rdb:1) @b{step+}
gcd.rb:12
if a == 1 or b-a == 0
(rdb:1) 
@end smallexample

If you want @code{step+} to be the default behavior when in
stepping. You can issue the command @code{set forcestep on}, (@pxref{Forcestep}). I
generally put this in my startup file @code{.rdebugrc}.


To be continued...

@itemize @bullet
@item next, where nesting inside blocks, iterators
@item more complex example with objects, pretty printing and irb.
@item line tracing and non-interactive tracing.
@item mixing in Debugger.debug with rdebug
@item post-mortem debugging and setting up for that
@item setting a breakpoint by modifying the program.
@item threading?
@item references to videos
@end itemize

@node Invocation
@chapter Getting in and out

@menu
* Starting the debugger::    How to enter the debugger
* Command Files::            Command files
* Quitting the debugger::    How to leave the debugger (quit, kill)
* Calling from Program::     Calling the debugger from inside your program
@end menu

It is also possible to enter the debugger when you have an uncaught
exception. See See also @ref{Post-Mortem Debugging}. 

@node Starting the debugger
@section Starting the debugger

Although one can enter @DBG{} via Emacs (described in a later section)
and possibly others interfaces, probably the most familiar thing to do
is invoke the debugger from a command line.

A wrapper shell script called @code{rdebug} basically @code{require}'s
the gem package @code{ruby-debug} and then loads @code{rdebug}.

@smallexample
rdebug [rdebug-options] [--] @var{ruby-script} @var{ruby-script-arguments...}
@end smallexample

If you don't need to pass dash options to your program which might get
confused with the debugger options, then you don't need to add the
@code{--}.

To get a brief list of options and descriptions, use the @code{--help}
option.

@smallexample
$ @b{rdebug --help}
ruby-debug 0.9.4
Usage: rdebug [options] <script.rb> -- <script.rb parameters>

Options:
    -s, --server                     Listen for remote connections
    -w, --wait                       Wait for a client connection, implies -s option
    -c, --client                     Connect to remote debugger
    -h, --host HOST                  Host name used for remote debugging
    -p, --port PORT                  Port used for remote debugging
        --cport PORT                 Port used for contol commands
        --no-control                 Do not automatically start control thread
    -x, --trace                      turn on line tracing
    -n, --nostop                     Do not stop when stript is loaded
    -m, --post-mortem                Activate post-mortem mode
    -I, --include PATH               Add PATH to $LOAD_PATH
        --script FILE                Name of the script file to run
    -r, --require SCRIPT             Require the library, before executing your script
        --keep-frame-binding         Keep frame bindings
        --emacs                      Activates emacs mode

Common options:
        --help                       Show this message
    -v, --version                    Show version
@end smallexample

Options for the @code{rdebug} are shown in the following list.  

@menu
* rdebug command-line options::   Options you can pass to rdebug
@end menu

@node rdebug command-line options
@subsection Options you can pass to rdebug

You can run @DBG{} in various alternative modes---for example, as a
program that interacts directly with the program in the same process
on the same computer or via a socket to another process possibly on a
different computer. 

Many options appear as a long option name, such as @code{--help}, and
a short one letter option name, such as @code{-h}. A double dash
(@code{--} is used to separate options which go to @code{rdebug} from
options that are intended to go to your Ruby script. Options (if any)
to @code{rdebug} should come first. If there is no possibility of the
Ruby script to be debugged getting confused with @code{rdebug}'s
option the double dash can be omitted.

@table @code
@item --help
@cindex @code{-h}
@cindex @code{--help}
This option causes @ttDBG{} to print some basic help and exit.

@item -v | --version
@cindex @code{-v}
This option causes @ttDBG{} to print its version number and exit.

@item -c | --client
@cindex @code{-c}
@cindex @code{--client}
Connect to remote debugger. The remote debugger should have been set
up previously our you will get a connection error and @code{rdebug}
will terminate. 

@item -s | --server
@cindex @code{-s}
@cindex @code{--server}
Debug the program but listen for remote connections on the default
port or port set up via the @code{--port} option. See also @code{--wait}.

@item -w | --wait
@cindex @code{-w}
@cindex @code{--wait}
Debug the program but stop waiting for a client connection first. This
option automatically sets @code{--server} option.

@item -p | --port @var{port}
@cindex @code{-p} @var{port}
@cindex @code{--port} @var{port}
Port used for remote debugging.

@item --cport @var{port}
@cindex @code{--cport} @var{port}
Port used for control commands.

@item -x | --trace
@cindex @code{-x}
@cindex @code{--trace}
Turn on line tracing.

@item -I --include @var{PATH}
@cindex @code{-I} @var{PATH}
@cindex @code{--include} @var{PATH}
Add @var{PATH} to @code{$LOAD_PATH}

@item -r | --require @var{library}
@cindex @code{-r}
@cindex @code{--require}
Require the library, before executing your script

@item --emacs
Activates GNU Emacs mode (@pxref{GNU Emacs}). Debugger output is tagged in
such a way to allow GNU Emacs to track where you are in the code.

@item --no-control
@cindex @code{--no-control}
Do not automatically start control thread.

@item --nostop
@cindex @code{--nostop}
Normally the @code{rdebug} stops before executing the first
statement. If instead you want it to start running initially and will
perhaps break it later in the running, use this options.

@item -m | --post-mortem
@cindex @code{-m}
@cindex @code{--post-mortem}
If your program raises an exception that isn't caught you can enter
the debugger for inspection of what went wrong. You may also want to
use this option in conjuctoin with @code{--no-stop}. See also 
@ref{Post-Mortem Debugging}. 

@item --keep-frame-binding
@cindex @code{--keep-frame-binding}
Bindings are used to set the proper environment in evaluating
expression inside the debugger.

By default, the debugger doesn't create binding object for each frame
when the frame is created, i.e. when a call is performed. Creating a
binding is an expensive operation and has been a major source of
performance problems.

Instead, the debugger create a binding when there is a need to
evaluate expressions. This artificial binding that is created can be
quite different from the real one.  In particular, in performing
constant and module name resolution.

However it's still possible to restore the old, slower behavior by
using this option or by setting @code{Debugger.keep_frame_binding =
true}.
@end table

@node Command Files
@section Command files

@cindex command files
A command file for @DBG{} is a file of lines that are @DBG{}
commands.  Comments (lines starting with @kbd{#}) may also be included.
An empty line in a command file does nothing; it does not mean to repeat
the last command, as it would from the terminal.

@cindex init file
@cindex @file{.rdebugrc}
When you start @value{DBG}, it automatically executes commands from its
@dfn{init files}, normally called @file{.rdebugrc}
During startup, @DBG{} does the following:

@enumerate
@item
Processes command line options and operands.

@item
Reads the init file in your current directory, if any, and failing
that the home directory. The home directory is the directory named in
the @code{HOME} or @code{HOMEPATH} environment variable. 

Thus, you can have more than one init file, one generic in your home
directory, and another, specific to the program you are debugging, in
the directory where you invoke @DBG{}.

@item
Reads command files specified by the @samp{--script} option.
@end enumerate

You can also request the execution of a command file with the
@code{source} command, @pxref{Source}.

@node Quitting the debugger
@section Quitting the debugger

@cindex interrupt
An interrupt (often @kbd{C-c}) does not exit from @value{DBG}, but
rather terminates the action of any @DBG command that is in
progress and returns to @value{DBG} command level.  Inside a debugger
command interpreter, use @code{quit} command (@pxref{Control, ,Quitting
the debugger}).

There way to terminate the debugger is to use the @code{kill}
command. This does more forceful @code{kill -9}. It can be used in
cases where @code{quit} doesn't work.

@node Calling from Program
@section Calling the debugger from inside your Ruby program

Running a program from the debugger adds a bit of overhead and slows
down your program a little.

Furthermore, by necessity, debuggers change the operation of the
program they are debugging. And this can lead to unexpected and
unwanted differences. It has happened so often that the term
``Heisenbugs'' (see @url{http://en.wikipedia.org/wiki/Heisenbug}) was
coined to describe the situation where the addition of the use of a
debugger (among other possibilities) changes behavior of the program
so that the bug doesn't manifest itself anymore.

There is another way to get into the debugger which adds no overhead
or slowdown until you reach the point at which you want to start
debugging. However here you must change the script and make an
explicit call to the debugger. Because the debugger isn't involved
before the first call, there is no overhead and the script will run
atDo the same speed as if there were no debugger.

There are three parts to calling the debugger from inside the script,
``requiring'' the debugger code, telling the debugger to start
tracking things and then making the call calling the debugger to
stop. 

To get the debugger class accessible from your Ruby program:

@smallexample
require 'rubygems'
require 'ruby-debug'
@end smallexample 
(It is very likely that you've already require'd rubygems. If so, you
don't have to do that again.) These commands need to be done only once.

To tell the debugger to start tracking calls and returns:

@smallexample
Debugger.start
@end smallexample 

There is also a @code{Debugger.stop} to turn off debugger tracking. If
speed is crucial, you may want to start and stop this around certain
sections of code.

And finally to enter the debugger:

@smallexample
debugger
@end smallexample 

You may want to do this at several points in the program where there
is a problem you want to investigate. And since debugger is just a
method call it's possible enclose it in a conditional expression, for
example:
@smallexample
debugger if foo='bar' and iter_count = 20
@end smallexample 

Although each step does a very specific thing which offers great
flexibility, in order to make getting into the debugger easier the
three steps have been rolled into one command:
@smallexample
require "ruby-debug/debugger"
@end smallexample 

@node Debugger Command Reference
@chapter @code{ruby-debug} Command Reference

@menu
* Command Syntax::           How to give commands to the rdebug
* Help::                     How to ask for help (help)
* Control::                  Controlling the debugger (quit, restart, interrupt)
* DisplayCommands::          Executing expressions on stop (display, undisplay)
* PrintCommands::            Evaluating and Printing Expressions (p, pp, ps, pp, irb)
* PrintVars::                Printing Variables (var)
* List::                     Examining Program Source Files (list)
* FrameCommands::            Examining the stack frame (where, up, down, frame)
* Stopping::                 Stopping and continuing (break, watch, step, cont...)
* ruby-debug settings::      rdebug-settings (set args, set autoeval, ...)
@end menu

@node Command Syntax
@section Command syntax

@node Help
@section Getting help (@samp{help})
@cindex online documentation

Once inside @code{ruby-debug} you can always ask it for information on its
commands, using the command @code{help}.

@table @code
@kindex h @r{(@code{help})}
@kindex help @ovar{command-name}
@item help
@itemx h
You can use @code{help} (abbreviated @code{h}) with no arguments to
display a short list of named classes of commands:

@flushleft
@smallexample
(rdb:1) @b{help}
ruby-debug help v0.9.4
Type 'help <command-name>' for help on a specific command

Available commands:
backtrace  delete   exit    info    next  putl     save    step       up   
break      display  finish  irb     p     quit     set     thread     var  
catch      down     frame   list    pp    reload   show    trace      where
continue   eval     help    method  ps    restart  source  undisplay
@end smallexample
@end flushleft
@c the above line break eliminates huge line overfull...

@end table 

@table @code
@item help @var{command}
With a command name as @code{help} argument, @DBG displays short
information on how to use that command.

@smallexample
(rdb:1) @b{help list}
ruby-debug help v0.9.4
l[ist]          list forward
l[ist] -        list backward
l[ist] =        list current line
l[ist] nn-mm    list given lines
* NOTE - to turn on autolist, use 'set autolist'
(rdb:1)
@end smallexample

@end table
@node Control
@section Controlling the debugger (@samp{quit}, @samp{restart}, @samp{interrupt}, @samp{source})

@menu
* Quit::      Quitting the debugger (quit)
* Restart::   Restarting Script execution (restart)
* Interrupt:: Interrupting the debugger (interrupt)
* Source::    Running Debugger commands (source)
@end menu

@node Quit
@subsection Quit (@samp{quit})
@table @code
@kindex quit 
@kindex q @r{(@code{quit})}
@item quit 
@item exit
@itemx q

To exit @value{DBG}, use the @code{quit} command (abbreviated
@code{q}), or alias @code{exit}.

A simple @code{quit} tries to terminate all threads in effect.
@end table

@node Restart
@subsection Restart (@samp{restart})
@table @code
@kindex restart @r{[}@var{program args}@r{]}
@kindex R @r{(@code{restart})}
@item restart
@itemx R 

Restart the program. This is is a re-exec - all debugger state is
lost. If command arguments are passed those are used. Otherwise the
last program arguments used in the last invocation are used.

In not all cases will you be able to restart the program. First, the
program should have been invoked at the outset rather than having been
called from inside your program or invoked as a result of post-mortem
handling. 

Also, since this relies on the the OS @code{exec} call, this command
is available only if your OS supports that @code{exec}; OSX for
example does not (yet).
@end table

@node Interrupt
@subsection Interrupt (@samp{interrupt})
@table @code
@kindex interrupt
@kindex i
@item interrupt
@itemx i
Interrupt the program. Useful if there are multiple threads running.
@end table

@node Source
@subsection Running Debugger Commands (@samp{source})
@table @code
@kindex source @var{filename}
@item source @var{filename}
Execute the command file @var{filename}.

The lines in a command file are executed sequentially.  They are not
printed as they are executed.  If there is an error, execution
proceeds to the next command in the file. For information about
command files that get run automaticaly on startup, @pxref{Command Files}.
@end table

@node DisplayCommands
@section Executing expressions on stop (@samp{display}, @samp{undisplay})
@cindex automatic display
@cindex display of expressions

If you find that you want to print the value of an expression
frequently (to see how it changes), you might want to add it to the
@dfn{automatic display list} so that @value{DBG} evaluates a statement
each time your program stops or the statement is shown in line tracing.
Each expression added to the list is given a number to identify it; to
remove an expression from the list, you specify that number.  The
automatic display looks like this:

@smallexample
(rdb:1) display n
1: n = 3
@end smallexample

@noindent
This display shows item numbers, expressions and their current values.  
If the expression is undefined or illegal the expression will be
printed but no value will appear.

@smallexample
(rdb:1) display undefined_variable
2: undefined_variable =
(rdb:1) display 1/0
3: 1/0 = 
@end smallexample

Note: this command uses @code{to_s} to in expressions; for example an
array @code{[1, 2]} will appear as @code{12}. For some datatypes like
an Array, you may want to call the @code{inspect} method, for example
@code{display ARGV.inspect} rather than @code{display ARGV}.

@table @code
@kindex display @ovar{expr}
@item display @var{expr}
Add the expression @var{expr} to the list of expressions to display
each time your program stops or a line is printed when linetracing is
on (@pxref{DisplayCommands}).

@item display
Display the current values of the expressions on the list, just as is
done when your program stops. 

@kindex undisplay @ovar{num}
@item undisplay @ovar{num}
@itemx delete display @var{num}
Remove item number @var{num} from the list of expressions to display.

@ifset GDB_COMPLETED
@code{undisplay} does not repeat if you press @key{RET} after using it.
(Otherwise you would just get the error @samp{No display number @dots{}}.)

@kindex disable display
@item disable display @var{dnums}@dots{}
Disable the display of item numbers @var{dnums}.  A disabled display
item is not printed automatically, but is not forgotten.  It may be
enabled again later.

@kindex enable display
@item enable display @var{dnums}@dots{}
Enable display of item numbers @var{dnums}.  It becomes effective once
again in auto display of its expression, until you specify otherwise.
@end ifset

@end table

@node PrintCommands
@section Evaluating and Printing Expressions (@samp{p}, @samp{pp}, @samp{putl}, @samp{ps}, @samp{irb})

One way to examine and change data in your script is with the
@code{eval} command (abbreviated @code{p}). A similar command is
@code{pp} which tries to prettyprint the result. Finally @code{irb} is
useful when you anticipate examining or changing a number of things,
and prefer not to have to preface each command, but rather work as one
does in @code{irb}.

@menu
* eval::          eval or print an expression (eval, p)
* pp::            pretty print an expression (pp, ps, putl)
* irb::           running irb using the current context
@end menu

@node eval
@subsection Printing an expression (@samp{eval}, @samp{p})
@table @code
@kindex eval @var{expr} 
@kindex p @r{(@code{eval})}
@item eval @var{expr}
@itemx p @var{expr}

Use @code{eval} or @code{p} to evaluate a Ruby expresson, @var{expr},
same as you would if you were in @code{irb}. If there are many expressions
you want to look at, you may want to go into irb from the debugger.
@smallexample
@group
(rdb:p) p n
3
(rdb:1) p "the value of n is #@{n@}"
"the value of n is 3"
(rdb:1)
@end group
@end smallexample
@end table

@node pp
@subsection Pretty-Printing an expression (@samp{pp}, @samp{putl}, @samp{ps}))
@table @code
@item pp
@kindex pp @var{expr}
Evaluates and pretty-prints @var{expr}
@smallexample
@group
(rdb:1) @b{p $LOAD_PATH}
["/home/rocky/lib/ruby", "/usr/lib/ruby/site_ruby/1.8", "/usr/lib/ruby/site_ruby/1.8/i586-linux", "/usr/lib/ruby/1.8"]
(rdb:1) @b{pp $LOAD_PATH}
["/home/rocky/lib/ruby",
 "/usr/lib/ruby/site_ruby/1.8",
 "/usr/lib/ruby/site_ruby/1.8/i586-linux",
 "/usr/lib/ruby/1.8"]
@end group
@end smallexample
@kindex putl
@item putl
If the value you want to print is an array, sometimes a columnized
list looks nicer:
@smallexample
@group
(rdb:1) @b{putl $LOAD_PATH}
/home/rocky/lib/ruby                    /usr/lib/ruby/site_ruby/1.8
/usr/lib/ruby/site_ruby/1.8/i586-linux  /usr/lib/ruby/1.8
@end group
@end smallexample

Note however that enteries are sorted to run down first rather than
across. So in the example above the second entry in the list is 
@code{/usr/lib/ruby/site_ruby/1.8/i586-linux} and the @emph{third} entry is 
@code{/usr/lib/ruby/site_ruby/1.8}.

If the value is not an array @code{putl} will just call pretty-print.
@kindex ps
@item ps
Sometimes you may want to print the array not only columnized, but
sorted as well. The list of debugger help commands appears this way,
and so does the output of the @code{method} commands.

@smallexample
@group
(rdb:1) ps Kernel.private_methods
Rational                 class_variable_get    included            private                   singleton_method_removed  
active_gem_with_options  class_variable_set    initialize          protected                 singleton_method_undefined
alias_method             define_method         initialize_copy     public                    timeout                   
append_features          extend_object         location_of_caller  remove_class_variable     undef_method              
attr                     extended              method_added        remove_const              y                         
attr_accessor            gem_original_require  method_removed      remove_instance_variable
attr_reader              hanoi                 method_undefined    remove_method           
attr_writer              include               module_function     singleton_method_added  
@end group
@end smallexample

If the value is not an array, @code{ps} will just call pretty-print.
See also the @code{methods}.
@end table

@node irb
@subsection Run irb (@samp{irb})
@table @code
@kindex irb 
@item irb
Run an interactive ruby session (@code{irb}) with the bindings
environment set to the state you are in the program.

When you leave irb and go back to the debugger command prompt we show
again the file, line and text position of the program in the same way
as when entered the debugger. If you issue a @command{list} without
location information, the default location used is the current line
rather than the position may have gotten updated via a prior
@command{list} command.
@smallexample
triangle.rb:4
def triangle(n)
(rdb:1) @b{list}
[-1, 8] in /home/rocky/ruby/triangle.rb
   1  #!/usr/bin/env ruby
   2  # Compute the n'th triangle number - the hard way
   3  # triangle(n) == (n * (n+1)) / 2
=> 4  def triangle(n)
   5    tri = 0
   6    0.upto(n) do |i|
   7      tri += i
   8    end
@b{irb}
>> @b{(0..6).inject@{|sum, i| sum +=i@}}
=> 21
>> @b{exit}
triangle.rb:4
def triangle(n)
(rdb:1) @b{list # Note we get the same line range as before going into irb}
[-1, 8] in /home/rocky/ruby/triangle.rb
   1  #!/usr/bin/env ruby
   2  # Compute the n'th triangle number - the hard way
   3  # triangle(n) == (n * (n+1)) / 2
=> 4  def triangle(n)
   5    tri = 0
   6    0.upto(n) do |i|
   7      tri += i
   8    end
@end smallexample

@end table

@node PrintVars
@section Printing Variables (@samp{var}, @samp{method})

@table @code
@item var const @var{object}
@kindex var const @var{expr}
Show the constants of @var{object}. This is basically iterating over
values in @var{object}@code{.constant}.
@item var instance @var{object}
@kindex var instance @var{expr}
Show the instance variables of @var{object}. This is basically listing
@var{object}@code{.instance_variables}.
@item var global
@kindex var global
Show global variables
@item var local
@kindex var local
Show local variables
@item method instance @var{object}
@kindex method instance @var{object}
Show methods of @var{object}. Basically this is the same as running
@code{ps object.instance_methods(false)} on @var{object}.
@item method @var{class-or-module}
@kindex method @var{class-or-module}
Show methods of the class or module, @var{class-or-module}. Basically
this is the same as running @code{ps object.methods} on @var{class-or-module}.
@end table

@node List
@section Examining Program Source Files (@samp{list})

@cindex current line
@value{DBG} can print parts of your script's source.  When your script
stops, @value{DBG} spontaneously prints the line where it stopped and
the text of that line. Likewise, when you select a stack frame
(@pxref{Selection}) @value{DBG} prints the line where execution in
that frame has stopped.  Implicitly there is a default line
location. Each time a list command is run that implicit location is
updated, so that running several list commands in succession shows a
contiguous block of program text.

You can print other portions of source files by giving an explicit
position as a parameter to the list command.

If you use @value{DBG} through its Emacs interface, you may prefer to
use Emacs facilities to view source; @pxref{GNU Emacs}.

@kindex list @ovar{line-number}
@kindex l @r{(@code{list})}
To print lines from a source file, use the @code{list} command
(abbreviated @code{l}).  By default, ten lines are printed. Fewer may
appear if there fewer lines before or after the current line to center
the listing around.

There are several ways to specify what part of the file you want to print.
Here are the forms of the @code{list} command.

@table @code
@item list @var{line-number}
@itemx l @var{line-number}
Print lines centered around line number @var{line-number} in the
current source file.

@item list
@itemx l
Print more lines.  If the last lines printed were printed with a
@code{list} command, this prints lines following the last lines
printed; however, if the last line printed was a solitary line printed
as part of displaying a stack frame (@pxref{Frames}), this prints lines
centered around that line.

@item list -
@itemx l -
Print lines just before the lines last printed.
@item list @var{first}-@var{last}
Print lines between @var{first} and @var{last} inclusive.

@item list =
Print lines centered around where the script is stopped.
@end table

Repeating a @code{list} command with @key{RET} discards the argument,
so it is equivalent to typing just @code{list}.  This is more useful
than listing the same lines again.  An exception is made for an
argument of @samp{-}; that argument is preserved in repetition so that
each repetition moves up in the source file.

@node FrameCommands
@section Examining the Stack Frame (@samp{where}, @samp{up}, @samp{down}, @samp{frame})

When your script has stopped, one thing you'll probably want to know
is where it stopped and some idea of how it got there.

@cindex call stack
Each time your script performs a function call (either as part of a
command substitution or not), or `source's a file, information about
this action is saved.  The call stack then is this a history of the
calls that got you to the point that you are currently stopped at.

@cindex selected frame
One of the stack frames is @dfn{selected} by @DBG{} and many
@DBG commands refer implicitly to the selected frame.  In
particular, whenever you ask @DBG to list lines without giving
a line number or location the value is found in the selected frame.
There are special @DBG commands to select whichever frame you
are interested in. @xref{Selection, ,Selecting a frame}.

When your program stops, @DBG{} automatically selects the
currently executing frame and describes it briefly, similar to the
@code{frame} command.

After switching frames, when you issue a @code{list} command without
any position information, the position used is location in the frame
that you just switched between, rather than a location that got
updated via a prior @code{list} command.

@menu
* Frames::                      Stack frames
* Backtrace::                   Backtraces (where)
* Selection::                   Selecting a frame (up, down, frame)

@end menu

@node Frames
@subsection Stack frames

@cindex frame, definition
@cindex stack frame
The call stack is divided up into contiguous pieces called @dfn{stack
frames}, or @dfn{frames} for short; each frame is the data associated
with one call to one function or method.  The frame contains the line
number of the caller of the function, the source-file name that the
line refers to a function name (which could be the built-in name
``source'')..

@cindex initial frame
@cindex outermost frame
@cindex innermost frame
When your script is started, the stack has only one frame, that of the
function @code{main}.  This is called the @dfn{initial} frame or the
@dfn{outermost} frame.  Each time a function is called, a new frame is
made.  Each time a function returns, the frame for that function invocation
is eliminated.  If a function is recursive, there can be many frames for
the same function.  The frame for the function in which execution is
actually occurring is called the @dfn{innermost} frame.  This is the most
recently created of all the stack frames that still exist.

@cindex frame number
@value{DBG} assigns numbers to all existing stack frames, starting with
zero for the innermost frame, one for the frame that called it,
and so on upward.  These numbers do not really exist in your script;
they are assigned by @value{DBG} to give you a way of designating stack
frames in @value{DBG} commands.

@node Backtrace
@subsection Backtraces (@samp{where})

@cindex backtraces
@cindex tracebacks
@cindex stack traces
A backtrace is essentially the same as the call stack: a summary of
how your script got where it is.  It shows one line per frame, for
many frames, starting with the place that you sare stopped at (frame
zero), followed by its caller (frame one), and on up the stack.

@table @code
@kindex where
@kindex w @r{(@code{where})}
@itemx where
Print a backtrace of the entire stack: one line per frame for all
frames in the stack.

@ifset FINISHED
@item backtrace @var{n}
@itemx bt @var{n}
@itemx where @var{n}
@itemx T @var{n}
Similar, but print only the innermost @var{n} frames.

@item backtrace -@var{n}
@itemx bt -@var{n}
@itemx where -@var{n}
@itemx T -@var{n}
Similar, but print only the outermost @var{n} frames.
@end ifset
@end table

@node Selection
@subsection Selecting a frame (@samp{up}, @samp{down}, @samp{frame})

Commands for listing source code in your script work on whichever
stack frame is selected at the moment.  Here are the commands for
selecting a stack frame; all of them finish by printing a brief
description of the stack frame just selected.

@table @code
@kindex up @ovar{n}
@item up @ovar{n}
Move @var{n} frames up the stack.  For positive numbers @var{n}, this
advances toward the outermost frame, to higher frame numbers, to
frames that have existed longer.  Using a negative @var{n} is the same
as issuing a @code{down} command of the absolute value of the @var{n}.
Using zero for @var{n} does no frame adjustment, but since the current
position is redisplayed, it may trigger a resyncronization if there is
a front end also watching over things. 

@var{n} defaults to one. You may appreviate @code{up} as @code{u}.

@kindex down @ovar{n}
@item down @ovar{n}
Move @var{n} frames down the stack.  For positive numbers @var{n}, this
advances toward the innermost frame, to lower frame numbers, to frames
that were created more recently.  Using a negative @var{n} is the same
as issuing a @code{up} command of the absolute value of the @var{n}.
Using zero for @var{n} does no frame adjustment, but since the current
position is redisplayed, it may trigger a resyncronization if there is
a front end also watching over things. 

@var{n} defaults to one.
@end table

@table @code
@kindex frame @ovar{n}
@cindex current stack frame
@item frame @ovar{n}
The @code{frame} command allows you to move from one stack frame to
another, and to print the stack frame you select.  @var{n} is the
the stack frame number;  @code{frame 0} then will always show the
current and most recent stack frame.

If a negative number is given, counting is from the other end of the
stack frame, so @code{frame -1} shows the least-recent, outermost or
most ``main'' stack frame.

Without an argument, @code{frame} prints the current stack
frame. Since the current position is redisplayed, it may trigger a
resyncronization if there is a front end also watching over
things. 
@end table

@node Stopping
@section Stopping and Resuming Execution

One important use of a debugger is to stop your program @emph{before}
it terminates, so that if your script runs into trouble you can
investigate and find out why. However should your script accidently
continue to termination, it can be arranged for @DBG to not to leave
the debugger without your explicit instruction. That way, you can
restart the program using the same command arguments.

Inside @value{DBG}, your script may stop for any of several reasons,
such as a signal, a breakpoint, or reaching a new line after a
debugger command such as @code{step}.  You may then examine and
change variables, set new breakpoints or remove old ones, and then
continue execution.  

@menu
* Breakpoints::          Breakpoints, watchpoints (break, tbreak, watch, watche, clear)
* Resuming Execution::   Resuming execution (continue, step, next, finish)
@end menu

@node Breakpoints
@subsection Breakpoints (@samp{break}, @samp{catch}, @samp{delete})

@cindex breakpoints
A @dfn{breakpoint} makes your script stop whenever a certain point in
the program is reached.  For each breakpoint, you can add conditions to
control in finer detail whether your script stops.  

You can specify the place where your script should stop with the
@code{break} command and its variants.

@cindex breakpoint numbers
@cindex numbers for breakpoints
@value{ttDBG} assigns a number to each breakpoint and watchpoint when
you create it; these numbers are successive integers starting with
one.  In many of the commands for controlling various features of
breakpoints you use the breakpoint number to say which breakpoint you
want to change.  

@table @code
@kindex break @ovar{location}
@kindex b @r{(@code{break})}
@item break
Set a breakpiont at the current line.

@item break @var{linenum}
Set a breakpoint at line @var{linenum} in the current source file.
The current source file is the last file whose source text was printed.
The breakpoint will stop your script just before it executes any of the
code on that line.

@item break @var{filename}:@var{linenum}
Set a breakpoint at line @var{linenum} in source file @var{filename}.

@item break @var{class}:@var{method}
Set a breakpoint in class @var{class} method @var{method}.

@kindex catch @ovar{exception}
@kindex cat @r{(@code{catch})}
@item catch
Set catchpoint to an exception. Without an exception name show catchpoints.


@cindex delete breakpoints
@kindex delete @ovar{breakpoints}
@kindex del @r{(@code{delete})}
@item delete @ovar{breakpoints}
Delete the breakpoints, watchpoints specified as arguments. 

If no argument is specified, delete all breakpoints (@DBG asks
confirmation.  You can abbreviate this command as @code{del}.
@end table

@node Resuming Execution
@subsection Resuming Execution (@samp{step}, @samp{next}, @samp{finish}, @samp{continue})

A typical technique for using stepping is to set a breakpoint
(@pxref{Breakpoints}) at the beginning of the function or the section
of your script where a problem is believed to lie, run your script
until it stops at that breakpoint, and then step through the suspect
area, examining the variables that are interesting, until you see the
problem happen.

@cindex stepping
@cindex continuing
@cindex resuming execution
@dfn{Continuing} means resuming program execution until your script
completes normally.  In contrast, @dfn{stepping} means executing just
one more ``step'' of your script, where ``step'' may mean either one
line of source code.  Either when continuing or when stepping,
your script may stop even sooner, due to a breakpoint or a signal.

@menu
* Step::          running the next statement (step)
* Next::          running the next statement skipping over functions (next)
* Finish::        running until the return of a function or ``source'' (finish)
* Continue::      continuing execution (continue)
@end menu

@node Step
@subsubsection Step (@samp{step})
@table @code
@kindex step @r{[}+@r{]} @ovar{count}
@kindex s @r{(@code{step})}
@item step @r{[}+@r{]} @ovar{count}
Continue running your program until the next logical stopping point
and return control to @value{DBG}. This command is abbreviated
@code{s}.

Like, the programming Lisp, Ruby tends implemented in a highly
expression-oriented manner. Therefore things that in other languages
that may appear to be a single statment are implemented in Ruby as
several expressions. For example, in an ``if'' statement or looping
statements a stop is made after the expression is evaluated but before
the test on the expression is made. 

So it is common that a lines in the program will have several stopping
points where in other debuggers of other languages there would be only
one. Or you may have several statements listed on a line.

When stepping it is not uncommon to want to go to a different line on
each step. If you want to make sure that on a step you go to a
@emph{different} position, add a plus sign (@samp{+}). 

If you find yourself generally wanting to use @code{step +} rather
than @code{step}, you may want to considier using @code{set
forcestep}, (@pxref{Forcestep}).

With a count, @code{step} will continue running as normal, but do so
@var{count} times.  If a breakpoint is reached, or a signal not
related to stepping occurs before @var{count} steps, stepping stops
right away.
@end table

@node Next
@subsubsection Next (@samp{next})
@table @code
@kindex next @r{[}+@r{]} @ovar{count}
@kindex n @r{(@code{next})}
@item next @r{[}+@r{]} @ovar{count}
This is similar to @code{step}, but function or method calls that
appear within the line of code are executed without stopping. As with
step, if you want to make sure that on a step you go to a
@emph{different} position, add a plus sign (@samp{+}).  Similarly, an
argument @var{count} is a repeat count, as for @code{step}.
@end table

@node Finish
@subsubsection Finish (@samp{finish})
@table @code
@kindex finish
@item finish
Continue running until just after the method or function returns.

If you want instead to terminate the program and debugger entirely,
use @code{quit} (@pxref{Quitting the debugger, ,Quitting the debugger}).

@end table

@node Continue
@subsubsection Continue (@samp{continue})
@table @code
@kindex continue @ovar{line-specification}
@kindex c @r{(@code{continue})}
@item continue @ovar{line-specification}
@itemx c @ovar{line-specification}
Resume program execution, at the address where your script last
stopped; any breakpoints set at that address are bypassed.  

The optional argument @var{line-specification} allows you to specify a
line number to set a one-time breakpoint which is deleted when that
breakpoint is reached.

Should the program stop before that breakpoint is reached, for
example, perhaps another breakpoint or watchpoint is reached first, in
a listing of the breakpoints you won't see this entry in the list of
breakpoints.
@end table

@node ruby-debug settings
@section ruby-debug settings (@samp{set args}, @samp{set autoeveal}..)

You can alter the way ruby-debug interacts with you using @code{set}
commands. 

The various parameters to @code{set} are given below. Each parameter
name needs to to be only enough to make it unique. For example
@code{set force} is a suitable abbreviation for @code{set forcestep}.
The letter case is not important, so @code{set FORCE} or @code{set
Force} are also suitable abbreviations.

Many @code{set} commands are either ``on'' or ``off'', and you can
indicate which way you want set by supplying the corresponding
word. The number 1 can be used for ``on'' and 0 for ``off''. If none
of these is given, we will assume ``on''. A depricated way of turning
something off is by prefacing it with ``no''.

Each @code{set} command has a corresponding @code{show} command which
allows you to see the current value.

@menu
* Args::                 Annotation Level
* Autoeval::             Evaluate unrecognized commands
* Autolist::             Execute ``list'' command on every breakpoint
* Autoirb::              Invoke IRB on every stop
* Autoreload::           Reload source code when changed
* Basename::             Report file basename only showing file names
* Callstyle::            SHow Report file basename only showing file names
* Forcestep::            Make sure 'next/step' commands always move to a new line
* Fullpath::             Display full file names in frames
* Keepframebindings::    Save frame binding on each call
* Linetrace::            line execution tracing
* Listsize::             Number of lines to try to show in a 'list' command
* Trace::                Display stack trace when 'eval' raises exception
* Width::                Number of characters the debugger thinks are in a line
@end menu

@node Args
@subsection Set/Show args

@table @code
@kindex set args @ovar{parameters}
@item set args @ovar{parameters}
Specify the arguments to be used if your program is rerun.  If
@code{set args} has no arguments, @code{restart} executes your program
with no arguments.  Once you have run your program with arguments,
using @code{set args} before the next @code{restart} is the only way to run
it again without arguments.

@kindex show args
@item show args
Show the arguments to give your program when it is started.
@end table

@node Autoeval
@subsection Set/Show auto-eval

@table @code
@kindex set autoeval @r{[} on | 1 | off | 0 @r{]}
@item set autoeval @r{[} on | 1 | off | 0 @r{]}
Specify that debugger input that isn't recognized as a command should
be passed to Ruby for evaluation (using the current debugged program
namespace). Note however that we @emph{first} check input to see if it
is a debugger command and @emph{only} if it is not do we consider it
as Ruby code. This means for example that if you have variable called
@code{n} and you want to see its value, you could use @code{p n},
because just entering @code{n} will be interpreted as the debugger
``next'' command.

See also @ref{irb} and @ref{Autoirb}.

When autoeval is set on, you'll get a different error message when you
invalid commands are encountered. Here's a session fragment to show
the difference
@smallexample
(rdb:1) @b{stepp}
Unknown command
(rdb:1) @b{set autoeval on}
autoeval is on.
(rdb:1) @b{stepp}
NameError Exception: undefined local variable or method `stepp' for ...
@end smallexample

@kindex show autoeval 
@item show args
Shows whether Ruby evaluation of debugger input should occur or not.
@end table

@node Autolist
@subsection Execute ``list'' command on every breakpoint

@node Autoirb
@subsection Set/Show auto-irb

@table @code
@kindex set autoirb @r{[} on | 1 | off | 0 @r{]}
@item set autoirb @r{[} on | 1 | off | 0 @r{]}

When your program stops, normally you go into a debugger command loop
looking for debugger commands. If instead you would like to directly
go into an irb shell, set this on. See also @ref{Autoeval} or
@ref{irb} if you tend to use debugger commands but still want Ruby
evaluation occasionally.

@kindex show autoirb
@item show autoirb
Shows whether the debugger will go into irb on stop or not.
@end table

@node Autoreload
@subsection Set/Show auto-reload

@node Basename
@subsection Set/Show basename

@table @code
@kindex set basename @r{[} on | 1 | off | 0 @r{]}
@item set basename @r{[} on | 1 | off | 0 @r{]}
Source filenames are shown as the shorter ``basename''
only. (Directory paths are omitted). This is useful in running the
regression tests and may useful in showing debugger examples as in
this text. You may also just want less verbose filename display.

By default filenames are shown as with their full path.

@kindex show basename
@item show basename
Shows the whether filename display shows just the file basename or not.
@end table

@node Callstyle
@subsection Set/Show call style

@table @code
@kindex set callstyle @r{[} short | last | tracked @r{]}
@item set forcestep @r{[} short | last | tracked @r{]}

Sets how you want call parameters displayed; @code{short} shows just
the parameter names; @code{last} shows the parameter names and the
class of these variables as they currently exist. Note the type could
have changed between when the call and its current
values. @code{tracked} is the most accurate but this adds
overhead. On every call, scalar values of the parameters get
saved. For non-scalar values the class is saved. 
@end table

@node Forcestep
@subsection Set/Show Forces Different Line Step/Next

@table @code
@kindex set forcestep @r{[} on | 1 | off | 0 @r{]}
@item set forcestep @r{[} on | 1 | off | 0 @r{]}

Due to the interpretive, expression-oriented nature of the Ruby
Language and implementation, each line often contains many possible
stopping points, while in a debugger it is often desired to treat each
line as an individual stepping unit. 

Setting forcestep on will cause each @code{step} or @code{next}
command to stop at a different line number. See also @ref{Step} and
@ref{Next}.

@kindex show forcestep
@item show forcestep
Shows whether forcestep is in effect or not.
@end table

@node Fullpath
@subsection Set/Show Frame full path

@node Keepframebindings
@subsection Save frame binding on each call

@node Linetrace
@subsection Set/Show Line tracing

@table @code
@kindex set linetrace @r{[} on | 1 | off | 0 @r{]}
@item set linetrace @r{[} on | 1 | off | 0 @r{]}

Setting linetrace on will cause lines to be shown before run.

@kindex show linetrace
@item show linetrace
Shows whether line tracing is in effect or not.
@end table

@node Listsize
@subsection Set/Show lines in a List command

@table @code
@kindex set listsize @var{number-of-lines}
@item set listsize @var{number-of-lines}
Set number of lines to try to show in a @code{list} command.
@kindex show listsize
@item show listsize
Shows the list-size setting.
@end table

@node Trace
@subsection Display stack trace when 'eval' raises exception

@node Width
@subsection Set/Show Line width

@table @code
@kindex set width @var{column-width}
@item set width @var{column-width}
Set number of characters the debugger thinks are in a line.
We also change OS environment variable @code{COLUMNS}. 
@kindex show width
@item show width
Shows the current width setting.
@end table

@node Post-Mortem Debugging
@chapter Post-Mortem Debugging
@cindex post-mortem debugging

It is also to possible enter the debugger when you have an uncaught
exception. This is called post-mortem debugging. In this state many of
the debugger commands for examining variables and moving around in the
stack will still work. However some commands such as those which imply
a continuation of running code will no longer work.

To set up post-mortem debugging you need to call
@code{Debugger.post_mortem} and it works in two ways. Called without a
block, it installs a global @code{at_exit} hook that intercepts
exceptions unhandled by your Ruby script.

If however you know that a particular block of code raises an
exception you can enable post-mortem mode by wrapping this block
inside a @code{Debugger.post_mortem} block

@smallexample
@cartouche
def offender
  1/0 
end
...
require "ruby-gems"
require "ruby-debug"
Debugger.post_mortem do
  ...
  offender
  ...
end
@end cartouche
@end smallexample 

@node Debugger Module and Class
@chapter The Debugger Module and Class

@menu
* Debugger Module::            ruby-debug's Debugger module
* Debugger Class::             Overview of Debugger with a sample session
* Kernel routines::            Routines added to Kernel
@end menu

@node Debugger Module
@section The Debugger Module

@ifset LATER
@menu
* Debugger.start::            
* Debugger.stop::    
* Debugger.post-mortem:: 
@end menu
@end ifset

@node Debugger Class
@section The Debugger Class

@node Kernel routines
@section Additions to Kernel 

@node GNU Emacs
@chapter Using @code{ruby-debug} from GNU Emacs

@cindex @value{Emacs}
A special interface which comes with Ruby that allows you to use
@value{Emacs} to view (and edit) the source files for the program you
are debugging with @value{DBG}. However you must be using
@value{Emacs} version 21 or greater. (@code{M-x show-emacs-version}
inside @value{Emacs} will tell you what version you are running.)

To use this interface, you to load @code{rubydb3x.el}. 

@smallexample
  (autoload 'rubydb "rubydb3x.el"  "Debugger Ruby programs." t)
  (setq rubydb-command-name "rdebug")
@end smallexample 

Once this is done, use the command @kbd{M-x rubydb} in @sc{gnu} Emacs.
Give the executable file you want to debug as an argument. Make sure
to use the version that comes with this package as this is newer than
that supplied with @value{Emacs}.

The @kbd{rubydb} command starts @value{DBG} as a subprocess of Emacs,
with input and output through a newly created Emacs buffer.

Using @value{DBG} under Emacs is just like using @value{DBG}
normally except for two things:

@itemize @bullet
@item
All ``terminal'' input and output goes through the GNU Emacs buffer.
@end itemize

This applies both to @value{DBG} commands and their output, and to the input
and output done by the program you are debugging.

This is useful because it means that you can copy the text of previous
commands and input them again; you can even use parts of the output
in this way.

All the facilities of GNU Emacs' Shell mode are available for interacting
with your script.  In particular, you can send signals the usual
way---for example, @kbd{C-c C-c} for an interrupt, @kbd{C-c C-z} for a
stop.

@menu
* GUD::           Commands from the GUD buffer
* Emacs Source::  Commands from the source script
* Emacs Shell::   @value{DBG} from a @value{Emacs} Shell
@end menu

@node GUD
@section Commands from the GUD buffer

@itemize @bullet
@item
@value{DBG} displays source code through Emacs.
@end itemize

Each time @value{DBG} displays a stack frame, Emacs automatically finds the
source file for that frame and puts an arrow (@samp{=>}) at the
left margin of the current line.  Emacs uses a separate buffer for
source display, and splits the screen to show both your @value{DBG} session
and the source.

Explicit @value{DBG} @code{list} or search commands still produce output as
usual, but you probably have no reason to use them from GNU Emacs.

@quotation
@emph{Warning:} If the directory where your script resides is not your
current directory, it can be easy to confuse Emacs about the location of
the source files, in which case the auxiliary display buffer does not
appear to show your source.  @value{DBG} can find programs by searching your
environment's @code{PATH} variable, so the @value{DBG} input and output
session proceeds normally; but Emacs does not get enough information
back from @value{DBG} to locate the source files in this situation.  To
avoid this problem, either start @value{DBG} mode from the directory where
your script resides, or specify an absolute file name when prompted for the
@kbd{M-x gdb} argument.

A similar confusion can result if you use the @value{DBG} @code{file} command to
switch to debugging a program in some other location, from an existing
@value{DBG} buffer in Emacs.
@end quotation

By default, @kbd{M-x rubydb} run the @code{ruby -r debug} which is the
other debugger.  However you can set this to @code{rdebug} by running this:

@smallexample
 (setq rubydb-command-name "rdebug")
@end smallexample

@noindent
(preceded by @kbd{M-:} or @kbd{ESC :}, or typed in the @code{*scratch*} buffer, or
in your @file{.emacs} file).

In the @value{DBG} I/O buffer, you can use the Emacs commands listed
below in addition to the standard Shell mode commands. The I/O buffer
name name is usually @code{*gud-}@emph{script-name}@code{*}, where
@emph{script-name} is the name of the script you are debugging.

Many of the commands listed below are also bound to a second key
sequence which also can be used in the also be used in the source
script. These are listed in @ref{Emacs Source}.

@table @kbd
@item C-h m
Describe the features of Emacs' @value{DBG} Mode.

@item C-c C-f
Execute until exit from the selected stack frame. The Same as @value{DBG}
@code{finish} command. The @value{Emacs} command name is
@code{gud-finish} and @code{C-x C-a f C-f} is an alternate binding
which also can be used in the source script. @xref{Finish}.

@item C-c C-l
Resynchronize the current position with the source window. The
@value{Emacs} command name is @code{gud-refresh} and @code{C-x C-a
C-l} is an alternate binding which also can be used in the source script.

@item C-c C-n
Execute to next source line in this function, skipping all function
calls. Same as @value{DBG} @code{next} command.  The @value{Emacs}
command name is @code{gud-next} and @code{C-x C-a n} is an
alternate binding which also can be used in the source script. @xref{Next}.

With a numeric argument, run that many times.
@xref{Arguments, , Numeric Arguments, Emacs, The @value{Emacs}
Manual}.

@item C-c C-r
Continue execution of your script Same as @value{DBG} @code{continue}
command. The @value{Emacs} command name is @code{gud-cont} and
@code{C-x C-a C-r} is an alternate binding which also can be used in the
source script. See @ref{Continue}.

@item C-c C-s
Step one source line. Same as @value{DBG} @code{step} command. The
@value{Emacs} command name is @code{gud-step} and @code{C-x C-a C-s}
is an alternate binding which can be used in the source
script. @xref{Step}.

With a numeric argument, run that many times.
@xref{Arguments, , Numeric Arguments, Emacs, The @value{Emacs}
Manual}.

@item C-c >
Go down a stack frame.  Same as @value{DBG} @code{down}.
With a numeric argument, go down that many stack frames.
@xref{Arguments, , Numeric Arguments, Emacs, The @value{Emacs}
Manual}.

The @value{Emacs} command name is
@code{gud-down} and @code{C-x C-a >} is an alternate binding
which can be used in the source script. 

@item C-c <
Go up a stack frame. With a numeric argument, go up that many
stack frames. Same @value{DBG} @code{up} command.
@xref{Arguments, , Numeric Arguments, Emacs, The @value{Emacs}
Manual}.

The @value{Emacs} command name is
@code{gud-up} and @code{C-x C-a <} is an alternate binding
which can be used in the source script. 

@item C-c a
Shows argument variables (e.g. @code{$1}, @code{$2}) of the current
stack frame. Same as @value{DBG} @code{info args} command. The
@value{Emacs} command name is @code{gud-args} and @code{C-x C-a a} is
an alternate binding which also can be used in the source script.

@item C-c R
Restart or run the script. Same as @value{DBG} @code{run} command. The
@value{Emacs} command name is @code{gud-finish} and @code{C-x C-a R}
is an alternate binding which also can be used in the source script.

@item C-c T
Show stack trace. Same as @value{DBG} @code{where} command. The
@value{Emacs} command name is @code{gud-where} and @code{C-x C-a T} is
an alternate binding which can be used in the source
script. @xref{Backtrace}.

@end table

In any source file, the Emacs command @kbd{C-x SPC} (@code{gud-break})
tells @value{DBG} to set a breakpoint on the source line point is on.

If you accidentally delete the source-display buffer, an easy way to get
it back is to type the command @code{frame} in the @value{DBG} buffer, to
request a frame display; when you run under Emacs, this recreates
the source buffer if necessary to show you the context of the current
frame.

The source files displayed in Emacs are in ordinary Emacs buffers
which are visiting the source files in the usual way.  You can edit
the files with these buffers if you wish; but keep in mind that @value{DBG}
communicates with Emacs in terms of line numbers.  If you add or
delete lines from the text, the line numbers that @value{DBG} knows cease
to correspond properly with the code.

@xref{Debugger Operation, , , Emacs, The @value{Emacs}
Manual}.

@node Emacs Source
@section Commands from the source script

@table @kbd
@item C-x SPC

tells @value{DBG} to set a breakpoint on the source
line point is on. (@code{gud-break}) 

@item C-x C-a t	

@code{gud-linetrace}

@item C-x C-a C-f
Restart or run the script. Same as @value{DBG} @code{run} command. The
@value{Emacs} command name is @code{gud-finish}. In the corresponding
I/O buffer, @code{C-c R} is an alternate binding.

@item C-x C-a T	
Show stack trace. Same as @value{DBG} @code{where} command. In the
corresponding I/O buffer, @code{C-c T} is an alternate
binding. @xref{Backtrace}.

@item C-x C-a <	

Go up a stack frame. With a numeric argument, go up that many
stack frames. Same @value{DBG} @code{up} command.
@xref{Arguments, , Numeric Arguments, Emacs, The @value{Emacs} Manual}.

The @value{Emacs} command name is @code{gud-up}. In the corresponding
I/O buffer, @code{C-c <} is an alternate binding.

@item C-x C-a >	

Go down a stack frame.  Same as @value{DBG} @code{down}.
With a numeric argument, go down that many stack frames.
@xref{Arguments, , Numeric Arguments, Emacs, The @value{Emacs}
Manual}.

The @value{Emacs} command name is @code{gud-down}. In the
corresponding I/O buffer, @code{C-c >} is an alternate binding.

@item C-x C-a C-t

@code{gud-tbreak}

@item C-x C-a C-s

Step one source line. Same as @value{DBG} @code{step}
command. @xref{Step}.

With a numeric argument, run that many times.
@xref{Arguments, , Numeric Arguments, Emacs, The @value{Emacs}
Manual}.

The @value{Emacs} command name is @code{gud-step}. In the
corresponding I/O buffer, @code{C-c C-s} is an alternate binding.

@item C-x C-a C-e

@code{gud-statement}

@item C-x C-a R	
Restart or run the script. Same as @value{DBG} @code{run} command. The
@value{Emacs} command name is @code{gud-run}. In the corresponding I/O
buffer, @code{C-c R} is an alternate binding.

@item C-x C-a C-d
Delete breakpoint. @code{gud-remove}

@item C-x C-a C-p

@code{gud-print}

@item C-x C-a C-n

Execute to next source line in this function, skipping all function
calls. Same as @value{DBG} @code{next} command.  With a numeric
argument, run that many times.  @xref{Arguments, , Numeric Arguments,
Emacs, The @value{Emacs} Manual}.

The @value{Emacs} command name is @code{gud-next}. In the
corresponding I/O buffer, @code{C-c C-n} is an alternate binding.

@item C-x C-a f	C-f

@code{gud-finish}

@item C-x C-a C-r
Continue execution of your script Same as @value{DBG} @code{continue}
command. The @value{Emacs} command name is @code{gud-cont}. In the
corresponding I/O buffer, @code{C-c C-r} is an alternate binding. See
@ref{Continue}.

@item C-x C-a C-b

@code{gud-break}

@item C-x C-a a	

@code{gud-args}
Shows argument variables (e.g. @code{$1}, @code{$2}) of the current
stack frame. Same as @value{DBG} @code{info args} command.  The
@value{Emacs} command name is @code{gud-args}. In the corresponding
I/O buffer, @code{C-c a} is an alternate binding which also can be
used in the source script.

@item C-x C-a C-l
Move to current position in this source window. The @value{Emacs}
command name is @code{gud-refresh}. In the corresponding I/O buffer,
@code{C-c C-l} is an alternate binding.

@end table

@node Emacs Shell
@section @value{DBG} from a @value{Emacs} Shell

It is also possible in GNU emacs to use a (``comint'') shell
and set a mode to watch for @value{DBG} prompts. @xref{Interactive
Shell, , Shell, Emacs, The @value{Emacs} Manual}.

To run Ruby in a shell in Emacs but track source lines this, issue the
command (from M-x) @code{turn-on-rdebugtrack}. There is some overhead
involved in scanning output, so if you are not debugging Ruby programs
you probably want to turn this off which can be done via the M-x
@code{turn-off-rdebugtrack} command.

@node Command Index
@unnumbered Command Index
@printindex ky

@node General Index
@unnumbered General Index
@printindex cp

@tex
% I think something like @colophon should be in texinfo.  In the
% meantime:
\long\def\colophon{\hbox to0pt{}\vfill
\centerline{The body of this manual is set in}
\centerline{\fontname\tenrm,}
\centerline{with headings in {\bf\fontname\tenbf}}
\centerline{and examples in {\tt\fontname\tentt}.}
\centerline{{\it\fontname\tenit\/},}
\centerline{{\bf\fontname\tenbf}, and}
\centerline{{\sl\fontname\tensl\/}}
\centerline{are used for emphasis.}\vfill}
\page\colophon
% Blame: doc@cygnus.com, 1991.
@end tex

@bye
